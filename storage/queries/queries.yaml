Dashboard:
  GetStore: |
    MATCH (t:Transaction)
    WHERE toString(t.timeCreated) =~ $date
    RETURN SUM(t.moneyRecieved) as revenue,
            SUM(t.moneySent) as expense
  GetRevenueByMonth: |
    MATCH (c:Transaction)-[e:INCOME]->(s:Store) 
      WHERE toString(c.timeCreated) =~ $date
      RETURN collect(c.moneyRecieved) AS totalValue, 
            collect(apoc.temporal.format(c.timeCreated, 'dd-MM-yyyy')) AS date;
  GetExpenseByMonth: |
    MATCH (c:Transaction)-[e:EXPENSE]->(s:Store) 
    WHERE toString(c.timeCreated) =~ $date
    RETURN collect(c.moneySent) AS totalValue, 
           collect(apoc.temporal.format(c.timeCreated, 'dd-MM-yyyy')) AS date;
  GetTotalPets: |
    MATCH (p:Pet|PetTool|Food) 
    OPTIONAL MATCH (i:Invoice)-[:PURCHASE]->(p) 
    WITH SUM(i.totalAmount) AS sold, 
         SUM(p.availableQuantity) AS available 
    RETURN sold, available;
  GetPPRevenueByMonth: |
    MATCH (i:Invoice WHERE toString(i.dateCreated) =~ $date)-[r:PURCHASE]->(p) 
    WHERE p:Pet OR p:PetTool 
    RETURN CASE 
             WHEN p:Pet THEN 'Pet' 
             ELSE 'PetTool' 
           END AS productType, 
           collect(toString(i.dateCreated)) AS invoiceDate, 
           collect(r.price) AS revenue 
    ORDER BY invoiceDate
  GetPetTopKPIList: |
    MATCH (s:Pet)<-[c:PURCHASE]-(i:Invoice) 
    WHERE toString(i.dateCreated) =~ $date 
    WITH s, sum(i.totalCost) as total
    ORDER BY total DESC 
    LIMIT 3 
    RETURN s.petName AS petName,  s.img AS img,
           total AS totalValue;

Invoice:
  GetInvoices: |
    MATCH(i:Invoice) 
    WHERE toString(i.dateCreated) =~ $date 
    RETURN {
    invoiceId: i.invoiceId, 
    totalAmount: i.totalAmount, 
    dateCreated: apoc.temporal.format(i.dateCreated, 'dd-MM-yyyy HH:mm:ss'),
    totalCost: i.totalCost } AS i
  GetDetailInvoice: |
   MATCH (t:Transaction)-[rp:PAY_FOR]->(i:Invoice {invoiceId: $id})-[r:PURCHASE]->(p:Pet|PetTool|Food) 
    WITH 
        {transactionId: t.transactionId, moneyRecieved: t.moneyRecieved, status: rp.status, type: t.type} AS transaction,
        {
            productName: CASE 
                            WHEN p:Pet THEN p.petName 
                            WHEN p:PetTool THEN p.toolName 
                            WHEN p:Food THEN p.foodName 
                            ELSE NULL 
                        END,
            price: p.price, 
            quantity: r.quantity
        } AS products
    RETURN transaction, collect(products) AS productList

  DeleteInvoice: |
    MATCH (i:Invoice{toString(dateCreated) ~= $date})-[r]->(t:Transaction) 
    DETACH DELETE t, i

Staff:
  GetStaffsWorking: |
    // không để DK date sau OPTIONAL MATCH: ko co -> null, de sau -> tra ve het, MATCH: ko có -> ko trả về
    // muc dich -> co hay khong thi van phai tra ve ds nhan vien, role, salary
    MATCH (st:Staff)-[r:ROLE]->(:Store)
    OPTIONAL MATCH (st)<-[:PAY_SALARY]-(t:Transaction WHERE toString(t.timeCreated) =~ $date)
    OPTIONAL MATCH (st)-[sw:SHIFTWORK WHERE toString(sw.date) =~ $date ]->()
    WITH st, 
        COALESCE(COLLECT({date:toString(sw.date), hour:sw.hour, phase: sw.phase}), []) AS shiftworks, 
        t.transactionId AS paid, 
        r.roleName AS role, 
        r.salary AS salary
    RETURN st, role, salary, shiftworks, paid

  PaySalary: |
    // không được nối trực tiếp nút staff -> nó sẽ tạo mới
    MATCH(s:Staff{staffId: $staffId})
    CREATE(:Transaction {transactionId: $id, moneyRecieved: 0, moneySent: $money, type: 'Banking',timeCreated: datetime($date)})
    -[:PAY_SALARY]->(s)

Product:
  GetProducts: |
    MATCH (i:Invoice WHERE toString(i.dateCreated) =~ $date)-[r:PURCHASE]->(p:Pet|PetTool) 
    WITH collect(i.invoiceId) as invoiceList, sum(r.quantity) AS totalQuantitySold, 
         sum(r.price) AS totalRevenue, 
         p 
    RETURN invoiceList, totalQuantitySold, totalRevenue, p
  GetAllProductName: |
    MATCH(p:Pet | PetTool | Food)
    RETURN CASE
          WHEN p:Pet THEN p.petName
          WHEN p:Food THEN p.foodName
          ELSE p.toolName END AS name
  UpdateProductPrice: |
    MATCH (p)
    WHERE (p:Pet AND p.petId = $id) 
      OR (p:PetTool AND p.toolId = $id) 
      OR (p:Food AND p.foodId = $id)
    SET p.price = $newPrice


Contract:
  GetContracts: |
   MATCH (c:Contract)-[o:OWNED_BY]->(v:Vendor) 
    WITH toString(c.signingDate) AS signingDate, c, o, v
    RETURN c{.*, signingDate: signingDate} AS c, o, v
  GetContractWithFilter: |
    MATCH (c:Contract)-[o:OWNED_BY{confirmStatus:$criteria}]->(v:Vendor) 
      WITH toString(c.signingDate) AS signingDate, c, o, v
      RETURN c{.*, signingDate: signingDate} AS c, o, v
  GetTotalContract: |
    MATCH (c:Contract) 
    RETURN COUNT(c) AS total;
  GetDetailContract: |
   MATCH (i:Pet|PetTool|Food)<-[p:PROVIDES]-(:Contract {contractId: $id}) 
    WITH p.totalAmount AS totalAmount, p.totalPrice AS totalPrice,
      CASE 
        WHEN i:Pet THEN i.petName
        WHEN i:PetTool THEN i.toolName
        WHEN i:Food THEN i.foodName
        ELSE NULL
      END AS productName
    RETURN {
      productName: productName, 
      totalAmount: totalAmount, 
      totalPrice: totalPrice
    } AS p
  FindContractNode: |
    MATCH(c:Contract{contractId: '$contractId'})
  CreateContractToPetRelationship: |
    CREATE (c)-[:PROVIDES{amount:$totalAmount, priceImport:$totalCost}]->(:Pet{petId: '$id'})
  CreateContractToPetToolRelationship: |
    CREATE (c)-[:PROVIDES{amount:$totalAmount, priceImport:$totalCost}]->(:PetTool{toolId: '$id'})
  CreateContractToFoodRelationship: |
    CREATE (c)-[:PROVIDES{amount:$totalAmount, priceImport:$totalCost}]->(:Food{foodId: '$id'})

  CreateCustomerContract: |
    CREATE (:Contract {contractId: $contractId, 
                       title: replace(trim($title), "  ", " "),
                       totalCost: $totalCost, 
                       signingDate: $signingDate, 
                       sellerName: $sellerName,
                       phone: $phone,
                       description: $description,
                       image: $image})
  CreateVendorContract: |
    MATCH (v:Vendor{vendorId: $vendorId}) 
    CREATE (:Contract {contractId: $contractId, 
                       title: replace(trim($title), "  ", " "),
                       totalCost: $totalCost, 
                       signingDate: $signingDate,
                       description: $description,
                       image: $image})-[:OWNED_BY{confirmStatus: false}]->(v)
  ConfirmContract: |
    MATCH (c:Contract {contractId: $id})-[r:OWNED_BY]->(), (s:Store)
    SET s.expense = s.expense + c.totalCost
    SET r.confirmStatus = true
  DeleteContract: |
    MATCH (c:Contract {contractId: $id}) 
    DETACH DELETE c

Promotion:
  GetPromotions: |
    MATCH (p:Promotion)-[a:ACTIVE_ON]->(pt)
    OPTIONAL MATCH (p)-[d:DISCOUNT]->(i:Invoice)
    WITH p, a, d, i,
         toString(a.dateStart) AS dateStart, 
         toString(a.dateEnd) AS dateEnd, 
         CASE 
           WHEN pt:Pet THEN pt.petName 
           WHEN pt:PetTool THEN pt.toolName 
           ELSE null 
         END AS productApplies 
    RETURN p, 
           {dateStart: dateStart, dateEnd: dateEnd} AS a, 
           collect(DISTINCT productApplies) as productApplies,{discount: SUM(d.discountValue), invoices: COUNT(i),
           profit: SUM(i.totalCost)} as specifications
  DeletePromotion: |
    MATCH (p:Promotion{promotionId: $id}) 
    DETACH DELETE p
  CreatePetPromotion: |
    CREATE (p:Promotion {promotionId: $promotionId, 
            value: $value, 
            description: $description, 
            title: $title})
            WITH p, $criterias AS criterias
            UNWIND criterias AS criteria  
            MERGE (p)-[r:ACTIVE_ON {dateStart: date($dateStart),  
                    dateEnd: date($dateEnd)}]->(:Pet{petName: criteria})  // Tạo mối quan hệ với Promotion
  CreatePetToolPromotion: |
    CREATE (p:Promotion {promotionId: $promotionId, 
         value: $value, 
         description: $description, 
         title: $title})
         WITH p, $criterias AS criterias
         UNWIND criterias AS criteria  
         MERGE (p)-[r:ACTIVE_ON {dateStart: date($dateStart),  
                                dateEnd: date($dateEnd)}]->(:PetTool{toolId: criteria})
Export:
  ProductRevenue: |
    MATCH (n:Pet|PetTool|Food)
    OPTIONAL MATCH (n)<-[r:PURCHASE]-(i:Invoice)
    WHERE toString(i.dateCreated) =~ $date OR i IS NULL
    WITH n, r, i, collect(toString(i.dateCreated)) AS invoiceDates
    RETURN 
      CASE 
        WHEN n:Pet THEN n.petName 
        WHEN n:PetTool THEN n.toolName 
        WHEN n:Food THEN n.foodName 
        ELSE "" 
      END AS name, 
      coalesce(r.quantity, 0) AS quantitySold, 
      n.availableQuantity AS availableQuantity,
      invoiceDates AS dates,
      coalesce(sum(i.totalCost), 0) AS totalRevenue,
      [i IN invoiceDates | CASE 
                            WHEN i IN invoiceDates THEN i 
                            ELSE 0 
                          END] AS values

  StoreRevenue: | 
    MATCH (n:Contract | Invoice)<-[pa:PAY_FOR]-(t:Transaction)-[:INCOME | EXPENSE]->(s:Store)
    OPTIONAL MATCH (n)-[r:PROVIDES | PURCHASE]->(p:Pet | PetTool | Food)
    WITH n, s, r, t, pa, p,
        CASE 
            WHEN p IS NOT NULL AND p:Pet THEN p.petName 
            WHEN p IS NOT NULL AND p:PetTool THEN p.toolName 
            WHEN p IS NOT NULL AND p:Food THEN p.foodName 
            ELSE NULL 
        END AS productName,
        CASE 
            WHEN n:Contract AND toString(n.signingDate) =~ $date THEN n.signingDate
            WHEN n:Invoice AND toString(n.dateCreated) =~ $date THEN n.dateCreated
            ELSE NULL
        END AS dateCreated,
        CASE 
            WHEN n:Contract THEN "Hợp đồng - " + n.contractId 
            WHEN n:Invoice THEN "Hóa đơn - " + n.invoiceId 
            ELSE "" 
        END AS name,
        n.totalCost AS totalCost,
        r.totalAmount AS amount
        WHERE dateCreated IS NOT NULL
        RETURN 
        name, 
        totalCost, 
        t.transactionId AS tranId,
        t.type AS method,
        pa.status AS status,
        toString(dateCreated) as dateCreated,
        collect(productName) AS productName, 
        collect(amount) AS amounts




