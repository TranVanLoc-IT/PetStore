Dashboard:
  GetStoreProfit: |
    MATCH (s:Store) RETURN s;
  GetStore: |
    MATCH (t:Transaction)
    WHERE toString(t.timeCreated) =~ $date
    RETURN SUM(t.moneyRecieved) as revenue,
            SUM(t.moneySent) as expense
  GetRevenueByMonth: |
    MATCH (c:Transaction)-[e:INCOME]->(s:Store) 
      WHERE toString(c.timeCreated) =~ $date
      RETURN collect(c.moneyRecieved) AS totalValue, 
            collect(apoc.temporal.format(c.timeCreated, 'dd-MM-yyyy')) AS date;
  GetExpenseByMonth: |
    MATCH (c:Transaction)-[e:EXPENSE]->(s:Store) 
    WHERE toString(c.timeCreated) =~ $date
    RETURN collect(c.moneySent) AS totalValue, 
           collect(apoc.temporal.format(c.timeCreated, 'dd-MM-yyyy')) AS date;
  GetTotalPets: |
    MATCH (p:Pet|PetTool|Food) 
    OPTIONAL MATCH (i:Invoice)-[:PURCHASE]->(p) 
    WITH SUM(i.totalAmount) AS sold, 
         SUM(p.availableQuantity) AS available 
    RETURN sold, available;
  GetPPRevenueByMonth: |
    MATCH (i:Invoice WHERE toString(i.dateCreated) =~ $date)-[r:PURCHASE]->(p) 
    WHERE p:Pet OR p:PetTool OR p:Food
    RETURN CASE 
             WHEN p:Pet THEN 'Thú cưng' 
             WHEN p:Food THEN 'Thức ăn' 
             ELSE 'Phụ kiện' 
           END AS productType, 
           sum(i.totalCost) AS revenue 
  GetTopKPIList: |
    MATCH (p:Pet | PetTool | Food)<-[c:PURCHASE]-(i:Invoice) 
    WHERE toString(i.dateCreated) =~ $date 
    WITH p, sum(i.totalCost) as total, 
    CASE 
          WHEN p:Pet THEN p.petName 
          WHEN p:PetTool THEN p.toolName 
          WHEN p:Food THEN p.foodName 
          ELSE NULL 
        END AS name
    ORDER BY total DESC 
    LIMIT 3 
    RETURN name, p.img AS img,
           total AS totalValue;

Invoice:
  GetInvoices: |
    MATCH(i:Invoice) 
    WHERE toString(i.dateCreated) =~ $date 
    RETURN {
    invoiceId: i.invoiceId, 
    totalAmount: COALESCE(i.totalAmount, 0), 
    dateCreated: apoc.temporal.format(i.dateCreated, 'dd-MM-yyyy HH:mm:ss'),
    totalCost: i.totalCost } AS i
  GetDetailInvoice: |
   MATCH (t:Transaction)-[rp:PAY_FOR]->(i:Invoice {invoiceId: $id})-[r:PURCHASE]->(p:Pet|PetTool|Food) 
    WITH 
        {transactionId: t.transactionId, moneyRecieved: t.moneyRecieved, status: rp.status, type: t.type} AS transaction,
        {
            productName: CASE 
                            WHEN p:Pet THEN p.petName 
                            WHEN p:PetTool THEN p.toolName 
                            WHEN p:Food THEN p.foodName 
                            ELSE NULL 
                        END,
            price: r.price, 
            quantity: r.quantity
        } AS products
    RETURN transaction, collect(products) AS productList
  GetPromotionApplies: |
    MATCH (i:Invoice {invoiceId: $id})<-[r:DISCOUNT]-(pr:Promotion) return r.discountValue as value, pr.title as name

  DeleteInvoice: |
    MATCH (i:Invoice{invoiceId: $id})<-[r:PAY_FOR]-(t:Transaction) 
    DETACH DELETE t, i

Staff:
  GetStaffsWorking: |
    // không để DK date sau OPTIONAL MATCH: ko co -> null, de sau -> tra ve het, MATCH: ko có -> ko trả về
    // muc dich -> co hay khong thi van phai tra ve ds nhan vien, role, salary
    MATCH (st:Staff)-[r:ROLE]->(:Store)
    OPTIONAL MATCH (st)<-[:PAY_SALARY]-(t:Transaction WHERE toString(t.timeCreated) =~ $date)
    OPTIONAL MATCH (st)-[sw:SHIFTWORK WHERE toString(sw.date) =~ $date ]->()
    WITH st, 
        COALESCE(COLLECT({date:toString(sw.date), hour:sw.hour, phase: sw.phase}), []) AS shiftworks, 
        t.transactionId AS paid, 
        r.roleName AS role, 
        r.salary AS salary
    RETURN st, role, salary, shiftworks, paid

  PaySalary: |
    // không được nối trực tiếp nút staff -> nó sẽ tạo mới
    MATCH (s:Staff {staffId: $staffId})
    MATCH (store:Store) // Nếu có điều kiện khác để xác định nút Store, cần thêm vào đây
    CREATE (t:Transaction {transactionId: $id, 
                          moneyRecieved: 0, 
                          moneySent: $money, 
                          type: 'Banking', 
                          timeCreated: datetime($date)})
    CREATE (t)-[:PAY_SALARY]->(s)
    SET store.totalExpense = store.totalExpense + t.moneySent;


Product:
  GetProducts: |
    // Thông tin SP bán ra trong tháng
    MATCH (i:Invoice WHERE toString(i.dateCreated) =~ $date)-[r:PURCHASE]->(p:Pet|PetTool|Food) 
    WITH collect(i.invoiceId) as invoiceList, sum(r.quantity) AS totalQuantitySold, 
         sum(r.price) AS totalRevenue, 
         p 
    RETURN invoiceList, totalQuantitySold, totalRevenue, p
  GetAllProductName: |
    MATCH(p:Pet | PetTool | Food)
    RETURN CASE
          WHEN p:Pet THEN p.petName
          WHEN p:Food THEN p.foodName
          ELSE p.toolName END AS name
  UpdateProductPrice: |
    MATCH (p)
    WHERE (p:Pet AND p.petId = $id) 
      OR (p:PetTool AND p.toolId = $id) 
      OR (p:Food AND p.foodId = $id)
    SET p.price = $newPrice


Contract:
  GetContracts: |
    MATCH (c:Contract)
    OPTIONAL MATCH (c)-[o:OWNED_BY]->(v:Vendor)
    WITH c, o, v,
    CASE 
        WHEN c.sellerName IS NULL THEN {vendorName: v.vendorName, phone: v.phone, confirm: o.confirmStatus}
        ELSE {vendorName: c.sellerName, phone: c.phone, confirm: true} 
    END AS vendor,
    toString(c.signingDate) AS signingDate
    RETURN c {.*, signingDate: signingDate}, vendor
  GetContractUnconfirmed: |
    MATCH (c:Contract)
    MATCH (c)-[o:OWNED_BY]->(v:Vendor)
    WHERE o.confirmStatus = $criteria
    WITH c, o, v,
        CASE 
            WHEN c.sellerName IS NULL THEN {vendorName: v.vendorName, phone: v.phone, confirm: o.confirmStatus}
            ELSE {vendorName: c.sellerName, phone: c.phone, confirm: true} 
        END AS vendor,
        toString(c.signingDate) AS signingDate
    RETURN c {.*, signingDate: signingDate}, vendor
  GetContractConfirmed: |
    MATCH (c:Contract)
    OPTIONAL MATCH (c)-[o:OWNED_BY]->(v:Vendor)
    WITH c, o, v,
        CASE 
            WHEN c.sellerName IS NULL THEN {vendorName: v.vendorName, phone: v.phone, confirm: o.confirmStatus}
            ELSE {vendorName: c.sellerName, phone: c.phone, confirm: true} 
        END AS vendor,
        toString(c.signingDate) AS signingDate
    WHERE o.confirmStatus = $criteria OR c.sellerName IS NOT NULL
    RETURN c {.*, signingDate: signingDate}, vendor
  GetTotalContract: |
    MATCH (c:Contract) 
    RETURN COUNT(c) AS total;
  GetDetailContract: |
   MATCH (i:Pet|PetTool|Food)<-[p:PROVIDES]-(:Contract {contractId: $id}) 
    WITH p.amount AS totalAmount, p.priceImport AS totalPrice,
      CASE 
        WHEN i:Pet THEN i.petName
        WHEN i:PetTool THEN i.toolName
        WHEN i:Food THEN i.foodName
        ELSE NULL
      END AS productName
    RETURN {
      productName: productName, 
      totalAmount: totalAmount, 
      totalPrice: totalPrice
    } AS p
  FindContractNode: |
    MATCH(c:Contract{contractId: '$contractId'})
  CreateContractToPetRelationship: |
    MATCH(p:Pet{petId: '$id'})
    MERGE (c)-[r:PROVIDES{amount:$totalAmount, priceImport:$totalCost}]->(p)
    ON CREATE SET r.amount = $totalAmount, r.priceImport = $totalCost
    ON MATCH SET r.amount = $totalAmount, r.priceImport = $totalCost;
  CreateContractToPetToolRelationship: |
    MATCH(p:PetTool{toolId: '$id'})
    MERGE (c)-[r:PROVIDES]->(p)
    ON CREATE SET r.amount = $totalAmount, r.priceImport = $totalCost
    ON MATCH SET r.amount = $totalAmount, r.priceImport = $totalCost;
  CreateContractToFoodRelationship: |
    MATCH(p:Food{foodId: '$id'})
    MERGE (c)-[r:PROVIDES]->(p)
    ON CREATE SET r.amount = $totalAmount, r.priceImport = $totalCost
    ON MATCH SET r.amount = $totalAmount, r.priceImport = $totalCost;

  CreateCustomerContract: |
    MERGE (c:Contract {contractId: $contractId})
    ON CREATE SET c.title = replace(trim($title), "  ", " "),
                  c.totalCost = $totalCost,
                  c.signingDate = $signingDate,
                  c.sellerName = $sellerName,
                  c.phone = $phone,
                  c.totalQuantity = $totalQuantity,
                  c.description = $description,
                  c.image = $image
    ON MATCH SET c.title = replace(trim($title), "  ", " "),
                  c.totalCost = $totalCost,
                  c.signingDate = $signingDate,
                  c.sellerName = $sellerName,
                  c.phone = $phone,
                  c.totalQuantity = $totalQuantity,
                  c.description = $description,
                  c.image = $image;

  CreateVendorContract: |
    MATCH (v:Vendor {vendorId: $vendorId})
    MERGE (c:Contract {contractId: $contractId})
    ON CREATE SET c.title = replace(trim($title), "  ", " "),
                  c.totalCost = $totalCost,
                  c.totalQuantity = $totalQuantity,
                  c.signingDate = $signingDate,
                  c.description = $description,
                  c.image = $image
    ON MATCH SET c.title = replace(trim($title), "  ", " "),
                  c.totalCost = $totalCost,
                  c.totalQuantity = $totalQuantity,
                  c.signingDate = $signingDate,
                  c.description = $description,
                  c.image = $image
    MERGE (c)-[r:OWNED_BY]->(v)
    ON CREATE SET r.confirmStatus = false;

  ConfirmContract: |
    MATCH (c:Contract {contractId: $id})-[r:OWNED_BY]->(), (s:Store)
    OPTIONAL MATCH (c)-[pr:PROVIDES]->(p:Pet)
    OPTIONAL MATCH (c)-[prt:PROVIDES]->(pt:PetTool)
    OPTIONAL MATCH (c)-[prf:PROVIDES]->(f:Food)
    // Update store's expense based on contract total cost
    SET s.totalExpense = s.totalExpense + c.totalCost
    SET r.confirmStatus = true
    WITH pr, prt, prf, p, pt, f
    FOREACH (_ IN CASE WHEN pr IS NOT NULL THEN [1] ELSE [] END |
        SET p.availableQuantity = p.availableQuantity + pr.amount
    )
    FOREACH (_ IN CASE WHEN prt IS NOT NULL THEN [1] ELSE [] END |
        SET pt.availableQuantity = pt.availableQuantity + prt.amount
    )
    FOREACH (_ IN CASE WHEN prf IS NOT NULL THEN [1] ELSE [] END |
        SET f.availableQuantity = f.availableQuantity + prf.amount
    )

  DeleteContract: |
    MATCH (c:Contract {contractId: $id}) 
    DETACH DELETE c

Promotion:
  GetPromotions: |
    MATCH (p:Promotion)-[a:ACTIVE_ON]->(pt)
    OPTIONAL MATCH (p)-[d:DISCOUNT]->(i:Invoice)
    WITH p, a, d, i,
         toString(a.dateStart) AS dateStart, 
         toString(a.dateEnd) AS dateEnd, 
         CASE 
           WHEN pt:Pet THEN pt.petName 
           WHEN pt:PetTool THEN pt.toolName 
           ELSE null 
         END AS productApplies
    ORDER BY dateStart
    RETURN p, 
           {dateStart: dateStart, dateEnd: dateEnd} AS a, 
           collect(DISTINCT productApplies) as productApplies,{discount: SUM(d.discountValue), invoices: COUNT(i),
           profit: SUM(i.totalCost)} as specifications
  DeletePromotion: |
    MATCH (p:Promotion{promotionId: $id}) 
    DETACH DELETE p
  CreatePetPromotion: |
    UNWIND $criterias AS criteria 
    MATCH(pt:Pet{petId: criteria})
    MERGE (p:Promotion {promotionId: $promotionId, 
            value: $value, 
            description: $description, 
            title: $title})
            MERGE (p)-[:ACTIVE_ON {dateStart: date($dateStart),  
                    dateEnd: date($dateEnd)}]->(pt);
  CreatePetToolPromotion: |
    UNWIND $criterias AS criteria 
    MATCH(pt:PetTool{toolId: criteria})
    MERGE (p:Promotion {promotionId: $promotionId, 
         value: $value, 
         description: $description, 
         title: $title})
         MERGE (p)-[:ACTIVE_ON {dateStart: date($dateStart),  
                                dateEnd: date($dateEnd)}]->(pt)
Export:
  ProductRevenue: |
    MATCH (n:Pet|PetTool|Food)
    OPTIONAL MATCH (n)<-[r:PURCHASE]-(i:Invoice)
    WHERE toString(i.dateCreated) =~ $date OR i IS NULL
    WITH n, r, i, collect(toString(i.dateCreated)) AS invoiceDates, collect(i.totalCost) as values
    RETURN 
      CASE 
        WHEN n:Pet THEN n.petName 
        WHEN n:PetTool THEN n.toolName 
        WHEN n:Food THEN n.foodName 
        ELSE "" 
      END AS name, 
      coalesce(r.quantity, 0) AS quantitySold, 
      n.availableQuantity AS availableQuantity,
      invoiceDates AS dates, values,
      coalesce(sum(i.totalCost), 0) AS totalRevenue;
      

  StoreRevenue: | 
    MATCH (n:Contract | Invoice)<-[pa:PAY_FOR]-(t:Transaction)-[:INCOME | EXPENSE]->(s:Store)
    OPTIONAL MATCH (n)-[r:PROVIDES | PURCHASE]->(p:Pet | PetTool | Food)
    WITH n, s, r, t, pa, p ,
        n.totalCost AS totalCost,
        CASE 
            WHEN p IS NOT NULL AND p:Pet THEN p.petName 
            WHEN p IS NOT NULL AND p:PetTool THEN p.toolName 
            WHEN p IS NOT NULL AND p:Food THEN p.foodName 
            ELSE NULL 
        END AS productName,
        CASE 
            WHEN n:Contract THEN n.totalQuantity
            WHEN n:Invoice THEN n.totalAmount
            ELSE NULL
        END AS amount,
        CASE 
            WHEN n:Contract AND toString(n.signingDate) =~ $date THEN n.signingDate
            WHEN n:Invoice AND toString(n.dateCreated) =~ $date THEN n.dateCreated
            ELSE NULL
        END AS dateCreated,
        CASE 
            WHEN n:Contract THEN "Hợp đồng - " + n.contractId 
            WHEN n:Invoice THEN "Hóa đơn - " + n.invoiceId 
            ELSE "" 
        END AS name
        WHERE dateCreated IS NOT NULL
        RETURN 
        name, 
        totalCost, 
        t.transactionId AS tranId,
        t.type AS method,
        pa.status AS status,
        toString(dateCreated) as dateCreated,
        collect(productName) AS productName, 
        collect(amount) AS amounts




